#!/usr/bin/env python3

import math

import rospy
import tf2_ros
from std_msgs.msg import Time
from geometry_msgs.msg import TransformStamped, PoseStamped
from custom_msgs.msg import Detection

# Use this to broadcoast pose estimation
class Tf2BroadcasterTarget:
    def __init__(self, camera_name="camera", target_name="target"):
        self.camera_name = camera_name
        self.target_name = target_name
        
        rospy.loginfo("tf2_broadcaster_target sending target found...")

        # Setup tf2 broadcaster and timestamp publisher
        self.tfbr = tf2_ros.TransformBroadcaster()
        self.pub_found = rospy.Publisher('/uav/target_found', Detection, queue_size=10)

    def send_tf_target(self, estimate_x=-0.4, estimate_y=0.2, estimate_z=1.35, detection_type="man"):
        if detection_type is None:
            rospy.logwarn("No detection type specified, cannot send 'target detected' message")
            return 

        # Generate our "found" timestamp
        time_found = rospy.Time.now()

        detection_msg = Detection()
        detection_msg.detection_time = Time()
        detection_msg.detection_time.data = time_found  # Set current time 
        detection_msg.object_name = detection_type

        # Initialize the pose field (PoseStamped) with zeros, as it will be overwritten        
        detection_msg.pose = PoseStamped()
        detection_msg.pose.header.stamp = time_found
        detection_msg.pose.pose.position.x = 0.0
        detection_msg.pose.pose.position.y = 0.0
        detection_msg.pose.pose.position.z = 0.0
        detection_msg.pose.pose.orientation.x = 0.0
        detection_msg.pose.pose.orientation.y = 0.0
        detection_msg.pose.pose.orientation.z = 0.0
        detection_msg.pose.pose.orientation.w = 1.0

        # Create a transform in the camera frame based on provided estimates
        t = TransformStamped()
        t.header.stamp = time_found
        t.header.frame_id = self.camera_name
        t.child_frame_id = self.target_name
        t.transform.translation.x = estimate_x
        t.transform.translation.y = estimate_y
        t.transform.translation.z = estimate_z
        t.transform.rotation.x = 0.0
        t.transform.rotation.y = 0.0
        t.transform.rotation.z = 0.0
        t.transform.rotation.w = 1.0

        # Send the transformation to TF and publish the "found" timestamp
        self.tfbr.sendTransform(t)
        self.pub_found.publish(detection_msg)
        rospy.loginfo(f'tf2_broadcaster_target sent detection msg- detection type: {detection_type}, pose: {t.transform.translation}')



if __name__ == '__main__':
	rospy.init_node('tf2_broadcaster_target')
	rospy.loginfo("tf2_broadcaster_target sending target found...")

	tf2broadcaster = Tf2BroadcasterTarget()

	# Give the nodes a few seconds to configure
	rospy.sleep(rospy.Duration(2))

	# Send out our target messages
	tf2broadcaster.send_tf_target()

	# Give the nodes a few seconds to transmit data
	# then we can exit
	rospy.sleep(rospy.Duration(2))
	rospy.loginfo("tf2_broadcaster_target sent TF and timestamp")