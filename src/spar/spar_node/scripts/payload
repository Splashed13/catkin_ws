#!/usr/bin/env python3

# Import ROS stuff
import rospy
from std_msgs.msg import Bool
# Import Python/Pi stuff
from gpiozero import AngularServo
from gpiozero import Servo
import time


sub_a = None
sub_b = None

# DEFINE YOUR SERVO PINS
servo1_pin = 17
servo2_pin = 18

# gpiozero Servo expects the position to be between -1 (min) and 1 (max)
# servo1 = GPIO.Servo(servo1_pin)
servo1 = AngularServo(servo1_pin, min_angle=0, max_angle=180, min_pulse_width=0.5/1000, max_pulse_width=2.27/1000)
# servo2 = GPIO.Servo(servo2_pin)
servo2 = AngularServo(servo2_pin, min_angle=0, max_angle=180, min_pulse_width=0.5/1000, max_pulse_width=2.27/1000)

# start both paylaods off completely closed and off to reduce jitter
servo1.min()
servo2.min()
time.sleep(1.5)
servo1.angle = None
servo2.angle = None

# Function to open and close payload container 1
def Deploy_Payload_1():
    print("Deploying Payload 1")
    # Open servo 1 (position 1 = fully open)
    servo1.max()
    # Wait for deployment to happen
    time.sleep(2)
    # Close payload 1 (position -1 = fully closed)
    servo1.min()
    # Turn off servo 1 (neutral position)
    time.sleep(1)
    servo1.angle = None
    print("Payload 1 Deployed")

# Function to open and close payload container 2
def Deploy_Payload_2():
    print("Deploying Payload 2")
    # Open servo 2 (position 1 = fully open)
    servo2.max()
    # Wait for deployment to happen
    time.sleep(2)
    # Close payload 2 (position -1 = fully closed)
    servo2.min()
    # Turn off servo 2 (neutral position)
    time.sleep(1)
    servo2.angle = None
    print("payload 2 Deployed")

# Deploy servo from ROS
def callback_a(msg_in):
    # Get the data out of the command
    servo = msg_in.data
    
    # Filter out bad values
    if servo != True:
        print("Incorrect Value, Enter True or False")
        return
    else:
        print("Payload 1 Message Recieved: ", servo)

    # Deploy the respective servo
    Deploy_Payload_1()


# Deploy servo from ROS
def callback_b(msg_in):
    # Get the data out of the command
    servo = msg_in.data
    
    # Filter out bad values
    if servo != True:
        print("Incorrect Value, Enter True or False")
        return
    else:
        print("Payload 2 Message Recieved: ", servo)

    # Deploy the respective servo
    Deploy_Payload_2()

	
def shutdown():
    # Clean up our ROS subscriber if they were set, avoids error messages in logs
    if sub_a is not None:
        sub_a.unregister()
    if sub_b is not None:
        sub_b.unregister()

    # XXX: Could perform some failsafe actions here!

    # Set servos to None to stop sending PWM signals
    servo1.angle = None
    servo2.angle = None

    # Close the pigpio pin factory to clean up resources
    # pin_factory.close()

    print("Resources are cleaned up")


# ===================================================================================================
# This is the main code
if __name__ == '__main__':
	# Setup the ROS backend for this node
	rospy.init_node('actuator_controller', anonymous=True)

	# Setup the publisher for a actuator 1 
	sub_a = rospy.Subscriber('/actuator_control/actuator_a', Bool, callback_a)
    # Setup the publisher for a actuator 2 
	sub_b = rospy.Subscriber('/actuator_control/actuator_b', Bool, callback_b)
    #
	# Make sure we clean up all our code before exiting
	rospy.on_shutdown(shutdown)

	# Loop forever
	rospy.spin()

# ===================================================================================================



# # run the test fu# # will set pin mode, or keep the preset mode
# mode = GPIO.getmode()
# if mode == None:
#     GPIO.setmode(GPIO.BCM)
# else:
#     GPIO.setmode(mode)
    
# # DEFINE YOUR SERVO PINS
# servo1_pin = 17
# servo2_pin = 18

# # SET PINS BE OUTPUTS
# GPIO.setup(servo1_pin, GPIO.OUT)
# GPIO.setup(servo2_pin, GPIO.OUT)

# # SET OUTPUT PINS TO PWM
# servo1 = GPIO.PWM(servo1_pin, 50)
# servo2 = GPIO.PWM(servo2_pin, 50)

# # START PWM SO SERVO IS CLOSED
# servo1.start(2)
# servo2.start(2)

# # Code to open payload container 1
# def Deploy_Payload_1():

#     #calc the required duty for open and close
#     duty_closed = 2 + (0 // 18)
#     duty_open = 2 + (180 // 18)

#     # Open servo 1
#     servo1.ChangeDutyCycle(duty_open)
#     # Wait for deployment to happen
#     time.sleep(1.5)
#     # Close payload 1
#     servo1.ChangeDutyCycle(duty_closed)
#     # Turn off servo 1
#     time.sleep(1)
#     servo1.ChangeDutyCycle(0)

# # Code to open payload container 2
# def Deploy_Payload_2():

#     #calc the required duty for open and close
#     duty_closed = 2 + (0 // 18)
#     duty_open = 2 + (180 // 18)

#     # Open servo 2
#     servo2.ChangeDutyCycle(duty_open)
#     # Wait for deployment to happen
#     time.sleep(1.5)
#     # Close payload 2
#     servo2.ChangeDutyCycle(duty_closed)
#     # Turn off servo 2
#     time.sleep(1)
#     servo2.ChangeDutyCycle(0)
# 
# ATTEMPT USING gpiozero 

# # # Set up pigpio pin factory
# pin_factory = PiGPIOFactory()

# sub_a = None
# sub_b = None

# # DEFINE YOUR SERVO PINS
# servo1_pin = 17
# servo2_pin = 18

# # gpiozero Servo expects the position to be between -1 (min) and 1 (max)
# servo1 = GPIO.Servo(servo1_pin, pin_factory=pin_factory)
# servo2 = GPIO.Servo(servo2_pin, pin_factory=pin_factory)

# # Set up servo objects
# # gpiozero Servo expects the position to be between -1 (min) and 1 (max)
# # servo1 = GPIO.Servo(servo1_pin)
# # servo2 = GPIO.Servo(servo2_pin)

# # Function to open and close payload container 1
# def Deploy_Payload_1():
#     # Open servo 1 (position 1 = fully open)
#     print("start")
#     servo1.max()
#     # Wait for deployment to happen
#     time.sleep(1.5)
#     # Close payload 1 (position -1 = fully closed)
#     servo1.min()
#     # Turn off servo 1 (neutral position)
#     time.sleep(4)
#     servo1.value = 0
#     print("finish")

# # Function to open and close payload container 2
# def Deploy_Payload_2():
#     # Open servo 2 (position 1 = fully open)
#     servo2.max()
#     # Wait for deployment to happen
#     time.sleep(1.5)
#     # Close payload 2 (position -1 = fully closed)
#     servo2.min()
#     # Turn off servo 2 (neutral position)
#     time.sleep(1)
#     servo2.value = 0