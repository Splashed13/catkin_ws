#!/usr/bin/env python3

import sys
from math import *

import rospy
import actionlib
from actionlib_msgs.msg import GoalStatus

from visualization_msgs.msg import Marker # Import for markers

from geometry_msgs.msg import Point, PoseStamped, Vector3

from spar_msgs.msg import FlightMotionAction, FlightMotionGoal

from nav_msgs.msg import Path

import tf.transformations

# Libraries for interfacing with breadcrumb
from breadcrumb.srv import RequestPath
from breadcrumb.srv import RequestPathRequest

from std_msgs.msg import Float32MultiArray, Bool

import random 

from custom_msgs.msg import Detection
from sensor_msgs.msg import BatteryState

# This is getting a bit more complicated now, so we'll put our information in
# a class to keep track of all of our variables. This is not so much different
# to the previous methods, other than the fact that the class will operate
# within itself.
# i.e. it will have it's own publishers, subscribers, etc., that
# will call it's own functions as callbacks, etc.
class Guidance():
	def __init__(self, waypoints):
		# Make sure we have a valid waypoint list
		if not self.check_waypoints(waypoints):
			raise ValueError("Invalid waypoint list input!")

		######################
		self.battery_per = 100  # Default battery percentage
		self.critical_battery = 0.2 # Critical battery percentage

		self.topic_battery = '/mavros/battery'
		try:
			# Attempt to subscribe to the battery topic
			self.sub_battery = rospy.Subscriber(self.topic_battery, BatteryState, self.callback_battery)
			rospy.loginfo(f"Subscribed to battery topic: {self.topic_battery}")  # Optional
		except rospy.ROSException as e: # ROSException to handle case where topic does not exist
			rospy.logwarn(f"Failed to subscribe to battery topic: {e}. Battery monitoring disabled.") # Indicate that topic could not be found or subscribed to
			self.sub_battery = None  # Set to None if subscription fails

		self.found_man = False
		self.found_backpack = False

		self.detected_markers = {}
		self.last_detected_marker = None

		# Internal counter to see what waypoint we are up to
		self.waypoint_counter = 0

		# Set a flag to indicate that we are doing a specific inspection
		# and that we are not following our waypoint list
		# This will stop our "waypoint is reached" callback from firing
		# during the roi diversion and taking over our flight!
		self.performing_roi = False
		self.breadcrumb_mode = False

		# Save the input waypoints
		self.waypoints = waypoints
	
		self.breadcrumb_waypoint_counter = 0
		self.breadcrumbWPs = []
		
		self.display_path(waypoints, "Waypoints")

		self.survey_altitude = rospy.get_param("~survey_altitude", 1)

		# Make some space to record down our current location
		self.current_location = Point() # useful for the nav functionality is peroidically updated
		# Set our linear and rotational velocities for the flight
		# these <~name> parameters are set in the launch file
		# if called with rosrun then 0.2 is used for example.
		self.vel_linear = rospy.get_param("~vel_linear", 0.2)
		self.vel_yaw = rospy.get_param("~vel_yaw", 0.2)
		# Set our position and yaw waypoint accuracies
		self.accuracy_pos = rospy.get_param("~acc_pos", 0.1)
		self.accuracy_yaw = rospy.get_param("~acc_yaw", 2)

		# Aruco subscriber
		self.sub_aruco = rospy.Subscriber('/emulated_uav/aruco', Float32MultiArray, self.callback_aruco)

		# Rviz marker publisher
		self.marker_pub = rospy.Publisher('/visualization_marker', Marker, queue_size=10) 
		

		self.actuator_pub_tracker = rospy.Publisher('/actuator_control/actuator_b', Bool, queue_size=10)
		self.actuator_pub_epipen = rospy.Publisher('/actuator_control/actuator_a', Bool, queue_size=10)

		# Create our action client
		action_ns = rospy.get_param("~action_topic", 'spar/flight')
		self.spar_client = actionlib.SimpleActionClient(action_ns, FlightMotionAction)
		rospy.loginfo("Waiting for spar...")
		self.spar_client.wait_for_server()
		rospy.loginfo("Connected to spar action server")


		# Wait to connect with Breadcrumb
		# Code will error if you try to connect to a service
		# that does not exist
		rospy.wait_for_service('/breadcrumb/request_path') # blocking code
		self.srvc_bc = rospy.ServiceProxy('/breadcrumb/request_path', RequestPath)
		

		if not rospy.is_shutdown():
			# Good to go, start mission
			rospy.loginfo("Starting waypoint mission")

			# Setup first waypoint segment
			# XXX:	Another option would be to do "takeoff" and leave "waypoint_counter = 0" to
			#		begin the mission at the first waypoint after take-off
			self.send_wp(self.waypoints[0])
			self.waypoint_counter += 1

			# Setup a timer to check if our waypoint has completed at 20Hz
			self.timer = rospy.Timer( rospy.Duration(1.0/20.0), self.check_waypoint_status )
			# Callback to save "current location" such that we can perform and return
			# from a diversion to the correct location
			# XXX: These topics could be hard-coded to avoid using a launch file
			self.sub_pose = rospy.Subscriber("~pose", PoseStamped, self.callback_pose)
			# Subscriber to catch "ROI" diversion commands
			self.sub_roi = rospy.Subscriber("~roi", Detection, self.callback_inspect_roi)

			# XXX: Could have a publisher to output our waypoint progress
			# throughout the flight (should publish each time the waypoint
			# counter is increased). Note: will also need to import "Float32"
			# from "std_msgs.msg" in the header
			# self.pub_progress = rospy.Subscriber("~waypoint_progress", Float32, 10)

			# If shutdown is issued (eg. CTRL+C), cancel current
	 		# mission before rospy is shutdown.
			rospy.on_shutdown( lambda : self.shutdown() )


	def display_path(self, wps, type_):
		pub_path = rospy.Publisher(f'/guidance/path{type_}', Path, queue_size=10, latch=True)
		msg = Path()
		msg.header.frame_id = "/map"
		msg.header.stamp = rospy.Time.now()

		for wp in wps:
			pose_ = PoseStamped()
			pose_.pose.position.x = wp[0]
			pose_.pose.position.y = wp[1]
			pose_.pose.position.z = wp[2]

			pose_.pose.orientation.w = 1  # Real part of the quaternion
			pose_.pose.orientation.x = 0  # i component of the quaternion
			pose_.pose.orientation.y = 0  # j component of the quaternion
			pose_.pose.orientation.z = 0  # k component of the quaternion

			msg.poses.append(pose_)

		pub_path.publish(msg)

	# This function will check if a list of waypoints is in the format we expect
	def check_waypoints(self, wps):
		# Make sure waypoints are a list
		if not isinstance(wps, list):
			rospy.logwarn("Waypoints are not list")
			return False

		# Make sure we have at least one waypoint
		if len(wps) < 1:
			rospy.logwarn("Waypoints list is empty")
			return False

		# Check each of our waypoints
		for i in range(len(wps)):
			if not self.check_waypoint(wps[i]):
				rospy.logwarn("Waypoint %i did not pass check" % (i + 1))
				return False

		# If we haven't returned false yet, then waypoints look good!
		return True


	# This function will check if a waypoint is in the format we expect
	def check_waypoint(self, wp):
		# Make sure each waypoint is a list
		if not isinstance(wp, list):
			rospy.logwarn("Waypoint is not a list of coordinates")
			return False

		# Make sure each waypoint has 4 values
		if len(wp) != 4:
			rospy.logwarn("Waypoint has an invalid length (must be X/Y/Z/Yaw)")
			return False

		# Check if waypoints are within arena boundaries (8x4) arena
		if abs(wp[0]) > 4 or abs(wp[1]) > 2.25 or abs(wp[2]) > 4 or (wp[2] < 0):
			rospy.logwarn(f'Waypoint has an invalid size for 0134 must be within arena bounds, problematic waypoints: {wp}')
			return False
		
		# If we haven't returned false yet, then waypoint looks valid!
		return True
	
	# This function will make sure we shut down the node as safely as possible
	def shutdown(self):
		# Unregister anything that needs it here
		self.sub_pose.unregister()
		self.sub_roi.unregister()
		self.spar_client.cancel_goal()

		rospy.loginfo("Guidance stopped")


	# This function will check receive the current pose of the UAV constantly
	def callback_pose(self, msg_in: PoseStamped):
		# Store the current position at all times so it can be accessed later
		if msg_in.pose.position:
			self.current_location = msg_in.pose.position
			#rospy.loginfo(f'current_location: {msg_in.pose.position}')
		# convert msg_in.pose.orientation (quaternion) to rpy.
		# if msg_in.pose.orientation:
		# 	_, _, self.current_yaw = self.quaternion_to_rpy(msg_in.pose.orientation)
		
	# This function will fire whenever a ROI pose message is sent
	# It is also responsible for handling the ROI "inspection task"
	def callback_inspect_roi(self, msg_in: Detection):
		rospy.loginfo(f'Recieved roi message object {msg_in.object_name}: {[msg_in.pose.pose.position.x, msg_in.pose.pose.position.y, msg_in.pose.pose.position.z]}')
		"""Callback for ROI detection messages."""
		is_aruco = False
		try:
			aruco_marker_id = int(msg_in.object_name)
			is_aruco = True
		except ValueError:
			pass
			
		if(is_aruco):
			# Check if we've already processed this detection_type (marker ID)
			if aruco_marker_id in self.detected_markers:
				rospy.loginfo(f"Ignoring detection with ID {aruco_marker_id}, already processed.")
				return
			# If not processed, store the detection in the dictionary
			self.detected_markers[aruco_marker_id] = [msg_in.pose.pose.position.x, msg_in.pose.pose.position.y, msg_in.pose.pose.position.z] 
			self.publish_detection_marker(msg_in.pose.pose.position, msg_in.object_name)
			rospy.loginfo(f'Sending vizualisation marker for aruco marker: {msg_in.object_name}')
			self.last_detected_marker = aruco_marker_id
			return

		# Process the message as before
		if msg_in.object_name == "man":
			if not self.found_man:
				self.publish_detection_marker(msg_in.pose.pose.position, msg_in.object_name)
				rospy.loginfo(f'Sending vizualisation marker for {msg_in.object_name}')
				self.found_man = True
			else:
				rospy.loginfo(f"Ignoring detection of {msg_in.object_name}, already processed.")
				return


		if msg_in.object_name == "bag": 
			if not self.found_backpack:
				self.publish_detection_marker(msg_in.pose.pose.position, msg_in.object_name)
				rospy.loginfo(f'Sending vizualisation marker for {msg_in.object_name}')
				self.found_backpack = True
			else:
				rospy.loginfo(f"Ignoring detection of {msg_in.object_name}, already processed.")
				return

		# Perform diversion to the detected object (as before)
		rospy.loginfo(f"Processing new detection: {msg_in}")
		self.performing_roi = True
		self.spar_client.cancel_goal()
		roi_inspection_altitude = 1
		dwp = [msg_in.pose.pose.position.x, msg_in.pose.pose.position.y, roi_inspection_altitude, 0.0]
		rwp = [self.current_location.x, self.current_location.y, self.current_location.z, 0.0]

		rospy.sleep(5)

		rospy.loginfo(f'Sending diversion waypoint: {dwp} returning {rwp}')
		self.send_wp(dwp)
		self.spar_client.wait_for_result()

		if self.spar_client.get_state() != GoalStatus.SUCCEEDED:
			rospy.signal_shutdown("cancelled")
			return

		rospy.loginfo("Reached diversion ROI!")	
		if(msg_in.object_name == "bag"):
			msg = Bool()
			msg.data = True
			self.actuator_pub_epipen.publish(msg)
			rospy.loginfo("Sending found bag message to payload node")
		if(msg_in.object_name == "man"):
			msg = Bool()
			msg.data = True
			self.actuator_pub_tracker.publish(msg)
			rospy.loginfo("Sending found bag message to man node")

		rospy.sleep(rospy.Duration(10))

		rospy.loginfo("Returning to flight plan...")
		self.send_wp(rwp)
		self.spar_client.wait_for_result()

		if self.spar_client.get_state() != GoalStatus.SUCCEEDED:
			rospy.signal_shutdown("cancelled")
			return

		if self.breadcrumb_mode:
			rospy.loginfo(f"Resuming breadcrumb path from waypoint {self.breadcrumb_waypoint_counter - 1}!")
			self.send_wp(self.breadcrumbWPs[self.breadcrumb_waypoint_counter - 1])
		else:
			rospy.loginfo(f"Resuming flight plan from waypoint {self.waypoint_counter - 1}!")
			self.send_wp(self.waypoints[self.waypoint_counter - 1])

		self.performing_roi = False

	# This function is for convinience to simply send out a new waypoint
	def send_wp(self, wp):
		# Make sure the waypoint is valid before continuing
		if not self.check_waypoint(wp):
			raise ValueError("Invalid waypoint input!")

		# Build the flight goal
		goal = FlightMotionGoal()
		goal.motion = FlightMotionGoal.MOTION_GOTO
		goal.position.x = wp[0]
		goal.position.y = wp[1]
		goal.position.z = wp[2]
		#goal.yaw = wp[3]
		goal.velocity_vertical = self.vel_linear
		goal.velocity_horizontal = self.vel_linear
		goal.yawrate = self.vel_yaw
		goal.wait_for_convergence = True
		goal.position_radius = self.accuracy_pos
		goal.yaw_range = self.accuracy_yaw

		# For this function, we don't wait in the loop.
		# Instead we just send the waypoint and check up on it later
		# This checking is either with the "self.timer" for waypoints
		# or with direct calls during the ROI diversion
		self.spar_client.send_goal(goal)
		 # If shutdown is issued, cancel current mission before rospy is shutdown
		rospy.on_shutdown(lambda : self.spar_client.cancel_goal())


	def callback_aruco(self, msg):
		"""Callback function for the /emulated_uav/aruco topic."""
		self.aruco_detections = list(msg.data)  # Store the received data
		rospy.loginfo("Received Aruco detection: %s", self.aruco_detections)


	# This function will fire whenever we recieve a timer event (te) from rospy.Timer()
	# The main purpose is to check if a waypoint has been reached,
	# and if so, send out the next waypoint to continue the mission
	def check_waypoint_status(self, te):
		#######################
		if self.sub_battery: # Check if the subscriber exists before checking battery percentage
			if self.battery_per <= self.critical_battery:
				rospy.logwarn("Battery level critical, initiating safe landing.")
				self.spar_client.cancel_goal()  # Cancel current goal
				self.send_low_battery_wp()  # Divert to safe landing
				return
			######################


		# If we're performing the ROI diversion, then don't do
		# anything here, as this is handled in that function
		if not self.performing_roi:
			# If the last segment has succeeded.
			# For more complex tasks, it might be necessary to also
			# check if you are in waypoint or diversion mode here.
			# Hint: really, we should check for other status states
			#		(such as aborted), as there are some states
			#		where we won't recover from, and should just exit
			if self.spar_client.get_state() == GoalStatus.SUCCEEDED:
				rospy.loginfo("Reached waypoint %i!" % (self.waypoint_counter))

				# XXX:	Another check could go here to finish the mission early
				#		if "all" inspection tasks have been completed
				#		(Add in another "if" and make the waypoint counter check
				#		 an "elif" check instead.
				#		 i.e. if complete; elif more wps; else wps finished)
				if self.waypoint_counter < (len(self.waypoints)):
					if not self.breadcrumb_mode:
						req = RequestPathRequest()
						req.start.x = self.waypoints[self.waypoint_counter-1][0] 
						req.start.y = self.waypoints[self.waypoint_counter-1][1]
						req.start.z = self.waypoints[self.waypoint_counter-1][2]
						req.end.x = self.waypoints[self.waypoint_counter][0]
						req.end.y = self.waypoints[self.waypoint_counter][1]
						req.end.z = self.waypoints[self.waypoint_counter][2]

						res = self.srvc_bc(req)

						# Breadcrumb will return a vector of poses if a solution was found
						# If no solution was found (i.e. no solution, or request bad
						# start/end), then breadcrumb returns and empty vector
						# XXX: You could also use res.path_sparse (see breadcrumb docs)
						breadcrumbWPs = []
						
						if len(res.path.poses) > 0:
							# Print the path to the screen
							rospy.loginfo(f"Waypoint {self.waypoint_counter-1} to Waypoint {self.waypoint_counter}:")
							rospy.loginfo("[%0.2f;%0.2f;%0.2f] => [%0.2f;%0.2f;%0.2f]",
										req.start.x,req.start.y,req.start.z,
										req.end.x,req.end.y,req.end.z)

							# Loop through the solution returned from breadcrumb
							for i in range(len(res.path.poses)):
								rospy.loginfo("    [%0.2f;%0.2f;%0.2f]",
											res.path.poses[i].position.x,
											res.path.poses[i].position.y,
											res.path.poses[i].position.z)
								

								breadcrumbWPs.append([res.path.poses[i].position.x,
											res.path.poses[i].position.y,
											self.survey_altitude, 0])

											
								print(f'Breadcrumb waypoints: {breadcrumbWPs}')
								self.breadcrumbWPs = breadcrumbWPs
								self.display_path(self.breadcrumbWPs, "Breadcrumb")
								self.breadcrumb_mode = True
								self.breadcrumb_waypoint_counter = 0
								self.send_wp(self.breadcrumbWPs[self.breadcrumb_waypoint_counter])
								self.breadcrumb_waypoint_counter += 1
							
						else:
							rospy.logerr("solution not found")

					else:
						if self.breadcrumb_waypoint_counter < (len(self.breadcrumbWPs)):
							self.send_wp(self.breadcrumbWPs[self.breadcrumb_waypoint_counter])
							# Increment our waypoint counter
							self.breadcrumb_waypoint_counter += 1
						else:
							self.waypoint_counter += 1
							self.breadcrumb_mode = False
				else:
					# Else the mission is over, shutdown and quit the node
					# XXX:	This could be used to restart the mission back to the
					#		first waypoint instead to restart the mission
					
					if(self.last_detected_marker):
						rospy.loginfo("Mission complete directing to last observed aruco marker for landing!")
						last_detected_marker = self.detected_markers[self.last_detected_marker]
						last_detected_marker_x = last_detected_marker[0]
						last_detected_marker_y = last_detected_marker[1]
						self.send_wp([last_detected_marker_x, last_detected_marker_y, 0, 0]) # Land on it
					else:
						rospy.loginfo("Mission complete no observed aruco marker returning to centre of map!")
						self.send_wp([0, 0, 0, 0])

					if self.spar_client.get_state() == GoalStatus.SUCCEEDED:
						rospy.loginfo("Final waypoint reached successfully! Shutting down process")
						rospy.signal_shutdown("complete")

			elif (self.spar_client.get_state() == GoalStatus.PREEMPTED) or (self.spar_client.get_state() == GoalStatus.ABORTED) or (self.spar_client.get_state() == GoalStatus.REJECTED):
				rospy.loginfo("Mission cancelled!")
				rospy.signal_shutdown("cancelled")

		
	def publish_detection_marker(self, position, object_name=None):
		"""Publishes a sphere marker and text label to RViz."""
		if(object_name is None):
			rospy.logwarn("Must include object name with marker publish to RVIZ")
		

		# Create the sphere marker
		marker = Marker()
		marker.header.frame_id = "map"
		marker.ns = "detections"
		marker.id =  random.randint(0, 2**31 - 1) 
		marker.type = Marker.SPHERE
		marker.action = Marker.ADD

		marker.pose.position = position
		marker.pose.position.z = 0
		marker.pose.orientation.w = 1.0  

		marker.scale = Vector3(0.2, 0.2, 0.2) 

		if(object_name == "man"):
			marker.color.r = 1.0
			marker.color.g = 0.0
			marker.color.b = 0.0
			marker.color.a = 1.0
		elif(object_name == "bag"):
			marker.color.r = 0.0
			marker.color.g = 0.0
			marker.color.b = 1.0
			marker.color.a = 1.0
		else:
			marker.color.r = 0.0
			marker.color.g = 1.0
			marker.color.b = 0.0
			marker.color.a = 1.0


		self.marker_pub.publish(marker)

		# Create the text marker
		text_marker = Marker()
		text_marker.header.frame_id = "map"
		text_marker.ns = "detections"
		text_marker.id =  random.randint(0, 2**31 - 1) 
		text_marker.type = Marker.TEXT_VIEW_FACING
		text_marker.action = Marker.ADD

		text_marker.pose.position.x = position.x
		text_marker.pose.position.y = position.y
		# text_marker.pose.position.z = position.z + 0.2 
		text_marker.pose.position.z = 0.2 

		text_marker.text = object_name
		text_marker.scale.z = 0.1  
		text_marker.color.a = 1.0
		text_marker.color.r = 1.0
		text_marker.color.g = 1.0
		text_marker.color.b = 1.0

		self.marker_pub.publish(text_marker)

		rospy.loginfo(f'Publising marker to rviz {object_name}: {position}')    

##################################
	def callback_battery(self, msg_in):
		"""Callback for battery state messages."""
		self.battery_per = msg_in.percentage

	def send_low_battery_wp(self):
		"""Send a waypoint to safely land the UAV due to low battery."""
		# 1. Check for Aruco Markers:
		if self.last_detected_marker is not None:
			rospy.loginfo(f"Landing on Aruco marker {self.last_detected_marker}.")
			landing_wp = self.detected_markers[self.last_detected_marker]
			landing_wp[2] = 0.0  # Land at ground level (z=0) 
			landing_wp[3] = 0.0
			self.send_wp(landing_wp)# 2. No Aruco, use default:
		else:
			rospy.loginfo("No Aruco marker found, landing at centre of arena.")
			default_wp = [0.0, 0.0, 0.0, 0.0] 
			self.send_wp(default_wp)

		self.spar_client.wait_for_result()
		if self.spar_client.get_state() == GoalStatus.SUCCEEDED:
			rospy.loginfo("Landed safely due to low battery.")
			rospy.signal_shutdown("Landed safely due to low battery.")
		else:
			rospy.logwarn("Safe landing failed, please intervene manually.")
			rospy.signal_shutdown("Landing intervention required.")
############################			
def main(args):
	# Initialise ROS
	rospy.init_node('guidance')

	# List of waypoints
	# [X, Y, Z, Yaw]
	# wps = [[ 0.0, 0.0, 1.0, 0.0],
	# 	   [ 1.0, 1.0, 1.0, 0.0],
	# 	   [-1.0, 1.0, 1.0, 0.0],
	# 	   [-1.0,-1.0, 1.0, 0.0],
	# 	   [ 1.0,-1.0, 1.0, 0.0],
	# 	   [ 0.0, 0.0, 1.0, 0.0]]

	survey_altitude = rospy.get_param("~survey_altitude", 1)

	if survey_altitude > 4 or survey_altitude < 0:
		rospy.logwarn("Survey Altitude to high must be 0m < x < 4m")
		return 

	wps = [[ 0.0, 0.0, survey_altitude, 0.0],
		[ 2.0, 2.0, survey_altitude, 0.0],
		[ 2.0, -2.0, survey_altitude, 0.0],
		[ 1.2, -2.0, survey_altitude, 0.0],
		[ 1.2, 2.0, survey_altitude, 0.0],
		[ 0.6, 2.0, survey_altitude, 0.0],
		[ 0.6, -2.0, survey_altitude, 0.0],
		[ -0.6, -2.0, survey_altitude, 0.0],
		[ -0.6, 2.0, survey_altitude, 0.0],
		[ -1.2, 2.0, survey_altitude, 0.0],
		[ -1.2, -2.0, survey_altitude, 0.0],
		[ -2.0, -2.0, survey_altitude, 0.0],
		[ -2.0, 2.0, survey_altitude, 0.0],
		[ -2.5, 2.0, survey_altitude, 0.0],
		[ -2.5, -2.0, survey_altitude, 0.0],
		[ 0.0, 0.0, survey_altitude, 0.0],
		[ 0.0, 0.0, 0.0, 0.0]]

	# Create our guidance class option
	guide = Guidance(wps)
	
	# Spin!
	rospy.spin()


if __name__ == '__main__':
	try:
		main(sys.argv)
	except rospy.ROSInterruptException:
		pass

	print('')
